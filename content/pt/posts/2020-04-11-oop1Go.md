---
title: "Orienta√ß√£o a Objetos em Go! - M√©todos"
date: 2020-04-11T10:55:22-03:00
description: "Entendendo POO em Go atrav√©s de exemmplos - parte 1"
toc: true
author: Alan Santos
authorEmoji: üë®üèª‚Äçüíª
authorDesc: IT Consultant
authorImage: "/images/whoami/avatar.jpg"
categories:
- Dev
tags:
- Go
meta_image: /images/feature3/golang.png
image: /images/feature3/golang.png
draft: false
---

## Orienta√ß√£o o objetos em Go

Na linguagem Go √© poss√≠vel programar utilizando o paradigma de Orienta√ß√£o a objetos.

Todavia, existem peculiaridades que tornam Go uma linguagem um pouco diferente de outras orientadas a objeto como o C Sharp e o Java.

### Algumas diferen√ßas

Para come√ßar, em Go n√£o existem classes como no Java e C Sharp. Go tamb√©m n√£o faz uso de prot√≥tipos (prototypes) como no Javascript (antes da implementa√ß√£o classes no mesmo).

Todavia, √© poss√≠vel criar objetos. Tamb√©m √© poss√≠vel atribuir m√©todos aos objetos, de modo que possamos interagir com os mesmos.

### Cria√ß√£o e uso de objetos em Go

Uma forma de criar objetos em Go √© atrav√©s do uso de Structs, mas isso ser√° abordado em um pr√≥ximo artigo.

Antes disso, vamos entender melhor como funciona a orienta√ß√£o a objetos em GO de forma mais conceitual, criando vari√°veis que s√£o objetos mais simples.

## Um exemplo de POO em Go

Para facilitar o entendimento, utilizaremos como exemplo um programa de convers√£o de temperatura.

Nosso conversor de temperatura ir√° converter a temperatura de 300 graus na escala kelvin para as escalas celsius e fahrenheit.

Para ilustrar de forma mais clara os conceitos que ser√£o apresentados, nosso conversor de exemplo n√£o far√° a entrada do valor via console.

Isso adicionaria mais complexidade, pois ter√≠amos que tratar poss√≠veis erros na entrada de dados pelo usu√°rio.

> Nosso objetivo aqui √© mostrar como funciona orienta√ß√£o a objetos em GO.

Ent√£o vamos l√°!

### Conversor de temperatura - Parte 1

#### Definindo tipos de objeto

Em Go, √© poss√≠vel que o programador defina seus pr√≥prios tipos de objeto.

Isso √© interessante pois melhora a legibilidade do programa e evita que erros bobos aconte√ßam, ao fazer com que um objeto somente aceite dados de um determinado tipo.

Em Go, o tipo de objeto criado pelo programador deve herdar as propriedades de algum tipo primitivo, como int (inteiros), float64 (valor de ponto flutuante de 64 bits) string (cadeia literal de caracteres).

Os tipos primitivos nada mais s√£o do que formas "padr√£o" de se armazenar dados na mem√≥ria de um computador para utiliza√ß√£o.

Ao inv√©s de utilizamos tipos primitivos, **vamos criar alguns tipos de objeto** para nosso conversor de temperatura:


```Golang

// PARTE 1
//
// tipos de objetos do tipo float64

type fahrenheit float64
type celsius float64
type kelvin float64

```
Na parte 1 de nosso programa, criamos 3 tipos de objetos: celsius, farhenheit e kelvin. Esses tipos de objeto, s√≥ podem armazenar valores do tipo float64.

#### Discuss√£o:
Aqui h√° uma quest√£o interessante a ser observada. Vejamos o trecho de c√≥digo abaixo. Vamos supor que tenhamos:

```
type kelvin float64

var x kelvin = 10.0
var y float64 = 10.0

```
**Se comparamos, por exemplo:  `if x == y` o resultado ser√° verdadeiro ou falso?**

> A resposta √©: falso!

Isso se d√° porque `x` √© uma vari√°vel do `tipo kelvin` e `y` √© uma vari√°vel do `tipo float64`. Tratam-se de **tipos diferentes** embora ambas vari√°veis possuam caracter√≠sticas do tipo primitivo float64.

Fazendo uma analogia, banana √© um tipo de fruta diferente do tipo de fruta ma√ß√£, embora ambas sejam tipos de frutas.

### Conversor de temperatura - Parte 2

Vamos voltar ao nosso programa exemplo. J√° criamos nossos "tipos" de temperaturas. Agora vamos criar m√©todos para interagir com objetos desses tipos.

A id√©ia aqui √© a seguinte: quando criarmos um objeto do `tipo kelvin`, teremos um m√©todo para interagir com ele. O mesmo vale para os outros tipos de objeto. A intera√ß√£o desejada ser√° fazer o c√°lculo (convers√£o) de um "objeto" temperatura.

Vamos l√°:

```Golang
// PARTE 2
//
// Cria√ß√£o de m√©todos para os tipos de objeto criados



// Cria m√©todo  celsius para interagir com objetos do tipo fahrenheit

func (f fahrenheit) celsius() celsius {
	return celsius((f - 32) * 5 / 9)
}



// Cria m√©todo celsius para interagir com objetos do tipo kelvin

func (k kelvin) celsius() celsius {
	return celsius(k - 273.15)
}



// Cria m√©todo fahrenheit para interagir com objetos do tipo celsius

func (c celsius) fahrenheit() farenheit {
	return fahrenheit(c*9/5) + 32
}



// Cria m√©todo  celsius para interagir com objetos do tipo fahrenheit

func (f fahrenheit) celsius() celsius {
	return celsius((f - 32) * 5 / 9)
}



// Cria m√©todo celsius para interagir com objetos do tipo kelvin

func (k kelvin) celsius() celsius {
	return celsius(k - 273.15)
}



// Cria m√©todo fahrenheit para interagir com objetos do tipo celsius

func (c celsius) fahrenheit() farenheit {
	return fahrenheit(c*9/5) + 32
}

```

#### Anatomia de um m√©todo:

Em Go, um m√©todo √© parecido com uma fun√ß√£o. Essa fun√ß√£o pode ter um ou v√°rios par√¢metros.

Mas o importante aqui √© que **o m√©todo aceita somente um determinado TIPO de receptor como par√¢metro**.

Se for passada √† fun√ß√£o algum argumento que n√£o seja do TIPO de receptor determinado, ocorrer√° erro de compila√ß√£o.

Para ilustrar nossa discuss√£o, vejamos o trecho de um c√≥digo abaixo, onde criamos 2 tipos de objeto (celsius e fahrenheit) e a seguir, criamos um m√©todo fahrenheit que somente pode receber objetos do tipo celsius (receiver).

Esse m√©todo retornar√° como resultado (no caso a convers√£o de temperatura), um valor do tipo fahrenheit.

```
type celsius float64
type fahrenheit float64

func (c celsius) fahrenheit() farenheit {
	return fahrenheit(c*9/5) + 32
}

```
Resumindo, criamos um m√©todo fahrenheit para objetos do tipo celsius.


#### Discuss√£o:

Aqui temos uma das principais diferen√ßas entre a orienta√ß√£o a objetos em Go e outras linguagens:

* Em algumas linguagens n√≥s temos classes (que s√£o modelos de objetos) e dentro das classes n√≥s temos os m√©todos.

* Quando criamos um objeto de uma determinada classe, aquele objeto j√° empacota o m√©todo para interagir com ele.


Em Go, criamos um tipo de objeto e associamos a ele um m√©todo, que vai interagir com aquele tipo. Quando o objeto do tipo determinado √© criado, h√° um m√©todo para interagir com ele.

> A grande diferen√ßa √©:  em **outras linguagens**, voc√™ **declara o m√©todo dentro da classe** que est√° criando.

> Em **Go**, o **m√©todo √© declarado fora da classe** e se assemelha mais a uma declara√ß√£o de fun√ß√£o.

### Conversor de temperatura - Parte 3

Vamos √† pr√≥xima parte de nosso conversor de temperatura.

O que fizemos at√© agora:
* J√° declaramos tipos de objetos que queremos criar quando nosso programar for executado.

* Tamb√©m criamos m√©todos que ir√£o interagir com os objetos baseados nos tipos de objeto que criamos.


Agora vamos criar nossos objetos propriamente ditos e vamos interagir com eles atrav√©s dos seus m√©todos durante a execu√ß√£o do programa:


```Golang
// PARTE 3
//
// ponto de √≠nicio para execu√ß√£o do programa.


func main() {

	// Cria objeto (Vari√°vel) do tipo kelvin e atribui valor 300

  var k kelvin = 300.0


	// cria objetos (vari√°veis) e deixa Go inferir de que tipo elas s√£o no momento da atribui√ß√£o de valor

	c := k.celsius()
	f := fahrenheit(c)


  // imprime resultado com 2 casas decimais

  fmt.Printf("%.2f kelvin = %.2f celsius = %.2f fahrenheit", k, c, f)

}

```

Primeiro criamos um objeto de nome `k` (no caso nosso objeto √© uma vari√°vel) do `tipo kelvin`. Esse objeto vai armazenar o valor 300.

Depois criamos um objeto de nome `c` e atribu√≠mos a ele o mesmo valor que guardamos em k, por√©m chamamos o m√©todo celsius, que n√≥s criamos para objetos do `tipo kelvin` (lembrando que `k` √© um objeto do `tipo kelvin`).

Logo, Go ir√° inferir que `c` √© do `tipo celsius`, pois j√° convertemos `k` para celsius, usando do m√©todo celsius.

O mesmo racioc√≠nio vale para o objeto `f`.

Por fim, utilizamos a fun√ß√£o printf do pacote fmt e realizamos a impress√£o do resultado, como argumentos os nossos 3 objetos criados: k, c, f.

Para melhorar a legibilidade, ainda estamos mostrando os resultados com apenas 2 casas decimais.

Se n√£o fiz√©ssemos isso, o resultado apresentado teria tantas casas decimais quanto s√£o permitidas em v√°ri√°veis do tipo float64 para os valores armazenados.

Vamos ao programa completo:

```Golang
// in√≠cio do programa definindo como pacote que ser√° executado

package main


// importa√ß√£o do pacote fmt (format), para realizarmos impress√£o

import "fmt"


// Defini√ß√£o de 3 tipos de objetos do tipo float64

type fahrenheit float64
type celsius float64
type kelvin float64


// Defini√ß√£o de m√©todos p/ interagir com objetos dos tipos definidos


// m√©todo  celsius para objetos do tipo fahrenheit
func (f fahrenheit) celsius() celsius {
	return celsius((f - 32) * 5 / 9)
}

// metodo celsius para objetos do tipo kelvin
func (k kelvin) celsius() celsius {
	return celsius(k - 273.15)
}

// metodo fahrenheit para objetos do tipo celsius
func (c celsius) fahrenheit() farenheit {
	return fahrenheit(c*9/5) + 32
}

// inicio do programa / ponto de entrada
func main() {

// cria objeto (Vari√°vel) do tipo kelvin e atribui valor 300
	var k kelvin = 300.0

// cria vari√°veis e deixa Go inferir o tipo de objeto durante a atribui√ß√£o
	c := k.celsius()
	f := fahrenheit(c)

// imprime resultado com 2 casas decimais
	fmt.Printf("%.2f kelvin = %.2f celsius = %.2f fahrenheit", k, c, f)

}
```

O mesmo programa, por√©m sem coment√°rios:



```Golang

package main

import "fmt"


type fahrenheit float64
type celsius float64
type kelvin float64


func (f fahrenheit) celsius() celsius {
	return celsius((f - 32) * 5 / 9)
}



func (k kelvin) celsius() celsius {
	return celsius(k - 273.15)
}



func (c celsius) fahrenheit() farenheit {
	return fahrenheit(c*9/5) + 32
}



func main() {

	var k kelvin = 300.0
	c := k.celsius()
	f := fahrenheit(c)

	fmt.Printf("%.2f kelvin = %.2f celsius = %.2f fahrenheit", k, c, f)

}
```

## Finalizando

Nesse artigo exemplificamos o b√°sico sobre orienta√ß√£o a objetos em Go, mostrando como definir tipos de objetos e como criar m√©todos para interagir com objetos desses tipos.

Os objetos criados aqui s√£o v√°riaveis, mas poderiam ser qualquer outro tipo de estrutura de armazenamento de dados dispon√≠vel em Go.

Em um outro momento, apresentaremos a cria√ß√£o de objetos mais complexos como structs, que se assemelham mais ao uso pr√°tico de classes de outras linguagens, por√©m com maior flexibilidade.

Espero que tenham gostado e at√© a pr√≥xima.
